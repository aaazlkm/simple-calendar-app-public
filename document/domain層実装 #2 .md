# domain層実装 #2

- todo
  - [x] imuutableに対応するListパッケージを探す
  - [x] usecaseについて調べる
  - [x] tzdateTimeを導入
  - [x] カレンダーの開始日と終了日を取れるようにしないといけない？
  - [x] RecurrenceRuleの考慮を含めたイベントを表示実装を考える
  - [x] コンバーター実装
  - [x] event dateの実装
  - [x] デフォルトカレンダーの扱いをどうするか
  - [x] service実装
  - [x] timezoneIDに変更する
  - [x] flutterでのテスト実装を調べる
  - [x] モデル実装
  - [x] RecurrenceRuleを別でやる理由
  - [x] RecurrenceRuleをTDD
    - 別issueにした

## RecurrenceRuleを別でやる理由

- あまりにも処理が思いと判断した
  - やるには数日かかる気がする
  - これだと、作業のやる気が出てこない
  - なので、この実装をやりつつ、他の部分も並行作業で行って行きたい
  - したがって、一旦RecurrenceRuleの作業を止めて、画面などを実装しながら、RecurrenceRuleを実装していきたいと思う

## RecurrenceRuleをTDDデ

- todo
  - [ ] daily
  - [ ] weekly
  - [ ] monthly
  - [ ] yearly
- endの決め方
  - endDateか、countか、それがなかったら、渡したdateRangeのendになる

## flutterでのテスト実装を調べる

- テストの種類
  - ユニとテスト
    - `test`パッケージ
  - ウィジェットテスト
    - `flutter_test`パッケージ
    - Widgetが期待通りに動作するか、期待通りのUIを実現できているか検証
  - インテグレーションテスト  
    - エミュレータ上で動かす
- テスト各場所
  - `/test`以下
  - テスト対象のファイルと同じ構成にする
- テストの流れ
  - setup
    - ダミーデータ用意する
  - group
    - テストケースをグループ化してわかりやすくできる
  - test
    - テストケース一件を表す

## デフォルトカレンダーの扱いをどうするか

- 方法
  - 1 Constantにデフォルトのカレンダーを用意して、そのカレンダーに対してイベントを追加する仕組みする
    - 保存タイミングどうするか
      - カレンダーが存在しなかったら、登録する処理を入れとく
      - これをカレンダー複数タイミングで削除しておく
  - 2 カレンダーを毎回Fetchして、そのカレンダーを下にカレンダーを表示する
- 比較
  - 1
    - pro
      - カレンダーが一つしかないことを保証することができる
      - イベントを直で取得できる
    - con
      - ~~カレンダーを複数にする際にちょっと微妙かも？~~
        - Constantでとるのをやめて、DBから取得して登録するようにするだけなので、そんなに大変ではない
      - カレンダーをクラウドで共有する時に、全員同じUUIDなのでかぶる
        - カレンダーをクラウドで共有する機能は実装しない気がするし
        - するのであれば、別アプリで作ることになると思う
          - このアプリはシンプルがコンセプトのアプリ
  - 2
    - pro
      - カレンダーを複数にする際にスムーズに移行することができそう
    - con
      - 必ず一つしかカレンダーが取得できないことを保証することができない
        - 複数かもしれないし、存在しないかもしれない
      - カレンダー取得してからイベントを取得しないとなので、遅れが生じる
      - カレンダーが消えた場合などとてもめんどくさいことになる
        - カレンダーを登録する処理などを入れていないために、復帰することができない
- 結論
  - 1にする
    - 1にすることでとりあえずカレンダーとしてちゃんと動くことは担保することができる
    - イベントの登録など楽
    - 2の場合、カレンダーが複数存在する場合、存在しない場合などのケアする処理がめんどくさい
      - 存在しない場合、表示する画面が存在しないことになるし
      - 複数存在する場合は、どれを表示すればいいのかわからん

## カレンダーの開始日と終了日を取れるようにしないといけない？

- その月とその月の+-1の月のイベントを渡せば大丈夫か

## イベントを表示する時の実装案を考える

- 問題
  - RecurrenceRuleによってイベントが複製されるが、その複製をいつ行えばいい感じになるか考える
- RRuleの役割
  - RRuleを持っているイベントは複数のdateをもつことになる
    - 保持してるdateが表示するDateRange内に存在する時に取得したい
  - RRuleで生成するDateはイベントの開始日
  - RRuleは単にDateを生成するだけの機能にしたい
  - まとめ
    - 条件を満たすDateのみを生成する
      - イベントへの変換は他で行う
    - 生成するのはイベントの開始日
    - RRuleが変わらない限り冪等性質を持つ
- 方法
  - 1 List<Date>を生成し、生成したDateをキャッシュしておく
    - これは一回普通に実装して、速度に問題があった場合に適用する
    - RRuleが変わらない限り冪等性質が存在するはず
    - dateStart, dateEnd内で生成したdateを保持しておく
    - dateStart, dateEndを超えたDateRangeを要求されたら、新しくdateを生成しそれを保持
    - RRuleに変更があった場合はキャッシュを削除し、新しく生成
- 流れ
  - RRuleでList<Date>を生成する
  - 生成されたDateを下にイベントを複製していく
    - Event内に自身を複製するようなメソッドを定義だな
  - カレンダーにそれらを渡す
  - 問題点
    - カレンダーのイベントを表示するためにイベントをフィルタリングすると思うが、
      - 単純にイベントの持つDateでフィルタリングしてしまうと、RRuleが考慮されないために表示されなイベントが出てきてしまう
      - なので、フィルタリングする際には、RRuleを考慮に含めないといけない
      - これをどうするかだな
      - 方法
        - イベントにDateRangeを渡し、該当するイベントを返すようにする
          - これを組み合わせてカレンダーを表示する
          - 具体
            - DateRangeに含まれていなければ
              - []
            - 含まれていたら該当するイベントを変換するようにする
              - [Event]

## RecurrenceRuleの実装

- 種類とそれぞれに必要な情報
  - none
    - ルールが適用されていない場合
    - nullで表される
  - daily
    - interval
  - weekly
    - interval
    - 何曜日か
  - monthly
    - interval
    - 月s
  - yearly
    - inerval
    - 年
- 必要な機能
  - DateRangeを渡して、その区間で表示するDateを作る
    - これmonthlyとかむずいな
    - どのように保持するか考える

## tzdateTimeを導入

- パッケージ
  - timemachine
    - pros
      - javatimeのようなAPIで使いやすそう
      - スター数も多い
    - cons
      - ただapi多すぎる
        - instantからoffset zoneまで
          - これらのinstantなどの機能はdateTimeで十分機能する
          - なので俺が探してる機能はTimeZoneを使用できるDateTimeだが、
            - それ以外の機能がたくさん入りすぎている
          - プロジェクト全体で依存した後に、保守されなくなった時が怖い
          - 正しく動いていない時が怖い
            - それの修正も遅くなってしまいそう
  - timezone
    - pros
      - 最小限のapi
      - dateTimeをベースに使用することができる
    - cons
      - 命名が微妙
- 結論
  - timezoneを使用する
    - 必要なTimeZoneの機能のみを使用することができる
      - timemachineは不必要な昨日にも依存してしまう
    - DateTimeをベースに実装できるので楽そう

## モデル実装

- エンティティをfreezedで作るかどうか

## usecaseについて調べる

- usecaseとは
  - CleanArchitectureで使われてるっぽい
  - usecaseはドメインのことを表してるわけではないらしい
  - ユーザとソフトウェアの間の会おうご関係を起こすアクション
  - アプリケーションがなければ存在しない
    - ユーザ認証や、バリデーションなどソフトウェがなければ存在しない
  - dddでもapplicationSercviceに近い
    - ここややこしかったから名前変更するのはナイス
  - 責務はタスクの調整であり、ユースケースのイベントフローごとにメソ度を提供する
    - これ、viewModelが存在すれば
  - clean アーキテクチャではusecaseがサービスと同じような働きをしてる感じがする
- ドメイン知識とは
  - ソフトウェア化する対象領域に存在するルール
  - ソフトウェがなくても、現実政界に存在する
  - 現実世界における知識
- 結論
  - 結局usecaseもサービスも同じようにアプリのビジネスロジックを表すように使われている
    - ただ、クリーンアーキテクチャでは、usecaseはdddでいうアプリケーションサービスのようなものと言われてるらしいので、ビジネスロジックを持たない気がする
      - つまり、誤った知識がweb上に広がっている感じがする
  - まあただ、ビジネスロジックを表すものとして共通認識が取れていればいい気がするので、命名はどちらでもいいかな
  - 今回はdddをせっかく勉強したので、serviceにビジネスロジックを記述する
  - あとはクリーンアーキテクチャの本を読む

## imuutableに対応するListパッケージを探す

- build collection
  - flutter favoriteがついてる
  - dart.devが開発してる
- kt.dart
  - pipemethodsがたくさんあって便利そう
    - getOrNullとかある
  - でも、これにプロジェクト全体で依存するのちょっといやかも
    - サポートされなくなったりしたら面倒
- 結論
  - build collectionを使用する
  - flutter favoriteがついてるし、有名そうなので、継続的に開発されそう
    - Listはプロジェクト全体で使用するものなので、ここが大事なポイント
    - もし開発されなくなったら、全とっかえしないといけなくなってしまう
      - その点が、kt.dartだとちょっと怪しいかなと感じた
  - pipelist処理はkt.dartの方がたくさんあっていい感じではあるが、
    - build collectionも十分な数公開している
    - メソッド名がkt由来なのもちょっと嫌だ
      - dartで書いているので、基本的にdartの命名規則にのっとったものを使いたい
